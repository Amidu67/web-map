<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Devtraco Estate Navigation</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css"/>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; font-family: Arial, sans-serif; }

    .navbar {
      position: absolute; top: 10px; right: 20px; z-index: 1000;
    }
    .navbar a {
      background: #007bff; color: white; padding: 8px 15px;
      margin-left: 10px; text-decoration: none; border-radius: 4px;
      transition: 0.3s;
    }
    .navbar a:hover { background: #0056b3; }

    .page { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    .active { display: block; }

    #home {
      background: url('https://devtraco.com/wp-content/uploads/2021/01/Untitled-design-2.jpg') center/cover no-repeat;
      display: flex; flex-direction: column; justify-content: flex-start; align-items: center;
      text-align: center; color: rgb(255, 255, 255); padding-top: 80px;
    }
    #home h1 {
      font-size: 3em; margin-bottom: 10px;
      color: #ffcc00;
      text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.8);
    }
    #home p { max-width: 600px; font-size: 1.33em; padding: 0 20px; margin-bottom: 20px; color: rgb(248, 249, 249); }
    button {
      padding: 15px 25px; background: #28a745; color: white;
      border: none; border-radius: 5px; cursor: pointer;
    }
    button:hover { background: #1e7e34; }

    /* Sentence box styling */
    .sentence-box {
      background-color: rgba(0, 0, 0, 0.6);
      border: 2px solid #ffcc00;
      border-radius: 10px;
      padding: 20px;
      margin: 20px 0;
      max-width: 600px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    #about {
      background: url('https://devtraco.com/wp-content/uploads/2021/01/Untitled-design-1.jpg') center/cover no-repeat;
      color: white;
      position: relative;
    }
    #about::before {
      content: "";
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      z-index: 1;
    }
    #about .content {
      position: relative;
      z-index: 2;
      padding: 80px 40px;
      text-align: center;
      max-width: 800px;
      margin: 0 auto;
    }
    /* Adjusted return button position on about page */
    #about .content button {
      margin-top: 30px;
    }

    #contact {
      background: #2c3e50; color: white; padding: 80px 40px;
    }

    #mapPage { background: white; color: #333; }
    #map { height: 100%; width: 100%; }

    .return-btn {
      position: absolute; top: 80px; left: 10px; z-index: 1000;
      background: #dc3545; color: white; border: none;
      padding: 8px 15px; border-radius: 4px;
    }

    .search-bar {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      background: white;
      padding: 8px;
      border-radius: 4px;
      display: flex;
      gap: 8px;
      align-items: center;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    .search-bar input {
      padding: 10px;
      width: 500px;
      font-size: 1em;
      border: 1px solid #ccc;
      border-radius: 3px;
    }
    .search-bar button {
      padding: 10px 15px; background: #007bff; color: white;
      border: none; border-radius: 3px; font-size: 1em;
    }

    .leaflet-routing-container {
      margin-top: 120px !important;
    }

    .blinking {
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    .gps-accuracy {
      stroke: #0078A8;
      stroke-width: 1;
      fill: #0078A8;
      fill-opacity: 0.15;
      pointer-events: none;
    }

    .loading-spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      border: 5px solid rgba(243, 243, 243, 0.8);
      border-top: 5px solid #3498db;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      background-color: rgba(255,255,255,0.8);
      display: none;
    }

    @keyframes spin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }

    .recenter-btn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
      background: #007bff;
      color: white;
      border: none;
      padding: 10px;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }

    .voice-controls {
      position: absolute;
      bottom: 70px;
      right: 20px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .voice-btn {
      background: #28a745;
      color: white;
      border: none;
      padding: 10px;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    
    /* Search results styling */
    #search-results {
      position: absolute;
      top: 100%;
      left: 0;
      width: 100%;
      max-height: 300px;
      overflow-y: auto;
      background: white;
      border: 1px solid #ccc;
      border-radius: 0 0 4px 4px;
      z-index: 1001;
      display: none;
    }
    .search-result {
      padding: 10px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
    }
    .search-result:hover {
      background-color: #f5f5f5;
    }

    /* Updated route line animation - faster and more solid */
    .route-line {
      stroke: #0066ff;
      stroke-width: 5;
      stroke-opacity: 0.9;
      stroke-dasharray: 20, 5;
      animation: dash 0.5s linear infinite;
    }

    @keyframes dash {
      0% { stroke-dashoffset: 25; }
      100% { stroke-dashoffset: 0; }
    }

    /* Upcoming route segment */
    .route-line-upcoming {
      stroke: #66ccff;
      stroke-width: 4;
      stroke-opacity: 0.5;
    }

    /* Custom popup styling */
    .leaflet-popup-content-wrapper {
      border-radius: 8px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.3);
    }
    .leaflet-popup-content {
      margin: 10px;
      text-align: center;
    }
    .leaflet-popup-content img {
      max-width: 250px;
      max-height: 250px;
      margin-top: 10px;
      border-radius: 4px;
      border: 1px solid #ddd;
    }
  </style>
</head>
<body>

<div class="navbar" id="navLinks">
  <a href="#" onclick="show('home')">Home</a>
  <a href="#" onclick="show('about')">About</a>
  <a href="#" onclick="show('contact')">Contact</a>
</div>

<div id="home" class="page active">
  <h1>Welcome to Devtraco Estate</h1>
  <div class="sentence-box">
    <p>Explore Devtraco with live GPS navigation, voice-guided directions, and seamless search functionality.</p>
  </div>
  <button onclick="show('map')">Start Navigation</button>
</div>

<div id="about" class="page">
  <div class="content">
    <h2>About Devtraco Estate</h2>
    <p>Devtraco Estate is a premier residential community located in the serene area of Tema Community 25, Accra, Ghana. It offers high-quality housing units with modern amenities, reliable security systems, excellent roads, and access to schools, hospitals, and shopping centers.</p>
    <p>Visit: <a href="https://devtraco.com" target="_blank" style="color: #ffcc00;">https://devtraco.com</a></p>
    <button onclick="show('home')">Return</button>
  </div>
</div>

<div id="contact" class="page">
  <div class="content">
    <h2>Contact Us</h2>
    <p>
      For inquiries and support:<br>
      üìß Email: info@devtraco.com<br>
      ‚òé Phone: +233‚ÄØ302‚ÄØ812‚ÄØ000<br>
      üìç Address: Devtraco Courts, Community 25, Tema, Ghana
    </p>
    <button onclick="show('home')">Return</button>
  </div>
</div>

<div id="mapPage" class="page">
  <button class="return-btn" onclick="show('home')">&larr; Back</button>
  <div class="search-bar">
    <input type="text" id="searchInput" placeholder="Search house number or location in Ghana"/>
    <button onclick="doSearch()">Search</button>
    <div id="search-results"></div>
  </div>
  <div id="map"></div>
  <div id="loadingSpinner" class="loading-spinner" style="display: none;"></div>
  <div class="voice-controls">
    <button class="voice-btn" onclick="repeatInstruction()" title="Repeat instruction">üîä</button>
  </div>
  <button class="recenter-btn" onclick="recenterMap()" title="Recenter on my location">üìç</button>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.min.js"></script>

<script>
  let map, routingControl, userMarker, accuracyCircle, userPos = [], instructions = [];
  let watchId = null;
  let lastSpokenInstruction = null;
  let nextInstructionIndex = 0;
  let isNavigating = false;
  let houseData = [];
  let roadData = [];
  let highlightedHouse = null;

  // Updated Devtraco Estate bounding box based on Building_point.json
  const estateBounds = {
    minLat: 5.7260,
    maxLat: 5.7400,
    minLon: 0.0390,
    maxLon: 0.0500
  };

  // Speak function with queue management
  let speechQueue = [];
  let isSpeaking = false;

  function speak(text) {
    if (!window.speechSynthesis) {
      console.warn("Speech synthesis not supported");
      return;
    }
    
    // Add to queue
    speechQueue.push(text);
    
    // If not currently speaking, start processing queue
    if (!isSpeaking) {
      processSpeechQueue();
    }
  }

  function processSpeechQueue() {
    if (speechQueue.length === 0) {
      isSpeaking = false;
      return;
    }
    
    isSpeaking = true;
    const text = speechQueue.shift();
    
    window.speechSynthesis.cancel();
    
    const utter = new SpeechSynthesisUtterance(text);
    utter.lang = 'en-US';
    utter.rate = 0.9;
    utter.pitch = 1.1;
    
    if (/Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) {
      utter.rate = 1.0;
      utter.volume = 1.5;
    }
    
    utter.onend = function() {
      setTimeout(processSpeechQueue, 500); // Small delay between messages
    };
    
    window.speechSynthesis.speak(utter);
  }

  // Play welcome message when page loads
  window.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
      speak("Welcome to Devtraco Estate Navigation System");
    }, 1000);
  });

  function show(id) {
    document.querySelectorAll('.page').forEach(e => e.classList.remove('active'));
    document.getElementById(id === 'map' ? 'mapPage' : id).classList.add('active');
    document.getElementById('navLinks').style.display = (id === 'map') ? 'none' : 'block';
    if (id === 'map') setTimeout(initMap, 300);
  }

  function initMap() {
    if (map) return;

    document.getElementById('loadingSpinner').style.display = 'block';

    map = L.map('map').setView([5.7328, 0.0447], 14);

    const streetLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '¬© OpenStreetMap contributors'
    });

    const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
      attribution: '¬© Esri, Maxar, Earthstar Geographics'
    });

    const labelsLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}.png', {
      attribution: '¬© CartoDB'
    });

    const baseLayers = {
      "Street": streetLayer,
      "Satellite with Labels": L.layerGroup([satelliteLayer, labelsLayer])
    };

    streetLayer.addTo(map);
    L.control.layers(baseLayers).addTo(map);

    // Load estate GeoJSON (houses) from Building_point.json
    fetch('Building_point.json')
      .then(response => {
        if (!response.ok) throw new Error('Failed to load house GeoJSON');
        return response.json();
      })
      .then(data => {
        houseData = data.features;
        console.log(`Loaded ${houseData.length} buildings from Building_point.json`);
      })
      .catch(error => {
        console.error('Error loading house data:', error);
        // Fallback to the sample data from your Building_point.json
        const sampleHouseData = {
          "type":"FeatureCollection",
          "features":[{
            "type":"Feature",
            "id":54,
            "geometry":{
              "type":"Point",
              "coordinates":[0.046657388234413413,5.7315854133107598]
            },
            "properties":{
              "FID":54,
              "TARGET_FID":1146,
              "OBJECTID_1":1140,
              "Northings":385586.78672799998,
              "Eastings":1280192.4411299999,
              "CreationDa":1752624000000,
              "Creator":"sfiatuga",
              "EditDate":1754092800000,
              "Editor":"sfiatuga",
              "HOUSE_NUMB":"SS14",
              "ORIG_FID":55,
              "Image_URL":"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRMNYAE53rdANIf0M0s82pbE9L8S6-c6s_fVQ&s"
            }
          }]
        };
        houseData = sampleHouseData.features;
        console.log('Using fallback building data with 1 house');
      });

    // Load road GeoJSON and cache for performance
    fetch('ROAD.json')
      .then(response => {
        if (!response.ok) throw new Error('Failed to load road GeoJSON');
        return response.json();
      })
      .then(data => {
        roadData = data.features;
      })
      .catch(error => {
        console.error('Error loading road data:', error);
        const sampleRoadData = {
          type: "FeatureCollection",
          features: [
            {
              type: "Feature",
              properties: { name: "Main Estate Road", type: "road", ROAD_ID: "R1" },
              geometry: {
                type: "LineString",
                coordinates: [
                  [0.0445, 5.7328],
                  [0.0447, 5.7328],
                  [0.0449, 5.7327]
                ]
              }
            },
            {
              type: "Feature",
              properties: { name: "Secondary Road", type: "road", ROAD_ID: "R2" },
              geometry: {
                type: "LineString",
                coordinates: [
                  [0.0446, 5.7329],
                  [0.0448, 5.7329],
                  [0.0450, 5.7330]
                ]
              }
            }
          ]
        };
        roadData = sampleRoadData.features;
      });

    // Initialize routing control with enhanced styling
    routingControl = L.Routing.control({
      waypoints: [],
      routeWhileDragging: false,
      collapsible: true,
      show: false,
      createMarker: () => null,
      formatter: new L.Routing.Formatter({
        language: 'en',
        units: 'metric'
      }),
      router: L.Routing.osrmv1({
        serviceUrl: 'https://router.project-osrm.org/route/v1',
        timeout: 5000,
        profile: 'driving'
      }),
      plan: L.Routing.plan([], {
        draggableWaypoints: false,
        addWaypoints: false
      }),
      lineOptions: {
        styles: [
          { className: 'route-line', weight: 5, opacity: 0.8 },
          { className: 'route-line-upcoming', weight: 4, opacity: 0.5 }
        ]
      }
    }).addTo(map);

    // Add loading indicator and error handling for routing
    routingControl.on('routestart', function() {
      document.getElementById('loadingSpinner').style.display = 'block';
    });

    routingControl.on('routesfound', function(e) {
      document.getElementById('loadingSpinner').style.display = 'none';
    });

    routingControl.on('routingerror', function(e) {
      document.getElementById('loadingSpinner').style.display = 'none';
      speak("Unable to calculate route. Please try a different location or check your connection.");
      alert("Routing error: Unable to find a route. Please try again or check road data.");
    });

    // Pre-warm routing engine
    setTimeout(() => {
      const dummyStart = [5.7328, 0.0447];
      const dummyEnd = [5.7330, 0.0449];
      routingControl.setWaypoints([
        L.latLng(dummyStart[0], dummyStart[1]),
        L.latLng(dummyEnd[0], dummyEnd[1])
      ]);
      setTimeout(() => routingControl.setWaypoints([]), 100);
    }, 500);

    // High-precision geolocation
    const geoOptions = {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 0
    };

    navigator.geolocation.getCurrentPosition(
      (p) => {
        updateUserPosition(p);
        document.getElementById('loadingSpinner').style.display = 'none';
      },
      (error) => {
        handleLocationError(error);
        document.getElementById('loadingSpinner').style.display = 'none';
      },
      geoOptions
    );

    watchId = navigator.geolocation.watchPosition(
      updateUserPosition,
      handleLocationError,
      geoOptions
    );

    routingControl.on('routesfound', function(e) {
      const routes = e.routes;
      instructions = routes[0].instructions;
      nextInstructionIndex = 0;
      isNavigating = true;
      
      if (instructions.length > 0) {
        speakInstruction(instructions[0]);
        nextInstructionIndex = 1;
      }
      
      const distance = (routes[0].summary.totalDistance / 1000).toFixed(1);
      speak(`Route calculated. Your destination is ${distance} kilometers away.`);
    });

    routingControl.on('routeselected', function(e) {
      const route = e.route;
      instructions = route.instructions;
      nextInstructionIndex = 0;
      isNavigating = true;
    });

    // Search input event listeners
    const searchInput = document.getElementById('searchInput');
    const searchResults = document.getElementById('search-results');
    
    searchInput.addEventListener('input', (e) => {
      const searchTerm = e.target.value.trim().toUpperCase();
      searchResults.innerHTML = '';
      
      if (searchTerm.length < 1) {
        searchResults.style.display = 'none';
        return;
      }
      
      const houseMatches = houseData.filter(house => 
        house.properties.HOUSE_NUMB && 
        house.properties.HOUSE_NUMB.toUpperCase().includes(searchTerm)
      ).slice(0, 5);
      
      houseMatches.forEach(house => {
        const resultItem = document.createElement('div');
        resultItem.className = 'search-result';
        resultItem.textContent = house.properties.HOUSE_NUMB;
        resultItem.addEventListener('click', () => {
          selectHouse(house);
          searchResults.style.display = 'none';
          searchInput.value = house.properties.HOUSE_NUMB;
        });
        searchResults.appendChild(resultItem);
      });
      
      if (houseMatches.length > 0) {
        searchResults.style.display = 'block';
      } else {
        searchResults.style.display = 'none';
      }
    });
    
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.search-bar')) {
        searchResults.style.display = 'none';
      }
    });
  }

  function isInEstate(lat, lon) {
    return lat >= estateBounds.minLat && lat <= estateBounds.maxLat &&
           lon >= estateBounds.minLon && lon <= estateBounds.maxLon;
  }

  function findNearestRoadPoint(lat, lon) {
    let minDistance = Infinity;
    let nearestPoint = null;
    let nearestRoadName = '';
    const maxSnapDistance = 50; // Max snapping distance in meters

    roadData.forEach(road => {
      if (road.geometry.type === 'LineString') {
        road.geometry.coordinates.forEach(coord => {
          const distance = map.distance([lat, lon], [coord[1], coord[0]]);
          if (distance < minDistance && distance <= maxSnapDistance) {
            minDistance = distance;
            nearestPoint = [coord[1], coord[0]]; // [lat, lon]
            nearestRoadName = road.properties.name || road.properties.ROAD_ID || 'road';
          }
        });
      }
    });

    return { point: nearestPoint, roadName: nearestRoadName, distance: minDistance };
  }

  function getRoadWaypoints(startLatLng, endLatLng) {
    const waypoints = [];
    
    // Snap start point to road if in estate
    if (isInEstate(startLatLng[0], startLatLng[1])) {
      const nearestStart = findNearestRoadPoint(startLatLng[0], startLatLng[1]);
      if (nearestStart.point && nearestStart.distance <= 50) {
        waypoints.push(L.latLng(nearestStart.point[0], nearestStart.point[1]));
        speak(`Starting from ${nearestStart.roadName}`);
      } else {
        waypoints.push(L.latLng(startLatLng[0], startLatLng[1]));
        speak("Starting from your current location, no nearby road found.");
      }
    } else {
      waypoints.push(L.latLng(startLatLng[0], startLatLng[1]));
    }

    // Route directly to destination (no snapping for destination)
    waypoints.push(L.latLng(endLatLng[0], endLatLng[1]));

    return waypoints;
  }

  function updateUserPosition(position) {
    const lat = position.coords.latitude;
    const lon = position.coords.longitude;
    // Limit accuracy circle to maximum 20 meters radius for visual clarity
    const accuracy = Math.min(position.coords.accuracy, 20); 
    
    userPos = [lat, lon];
    
    const customIcon = L.icon({
      iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      className: 'blinking'
    });

    if (userMarker) {
      userMarker.setLatLng(userPos);
    } else {
      userMarker = L.marker(userPos, { icon: customIcon }).addTo(map);
    }

    if (accuracyCircle) {
      accuracyCircle.setLatLng(userPos).setRadius(accuracy);
    } else {
      accuracyCircle = L.circle(userPos, {
        radius: accuracy,
        className: 'gps-accuracy'
      }).addTo(map);
    }

    if (isNavigating && instructions.length > 0) {
      checkNextInstruction();
    }
  }

  function checkNextInstruction() {
    if (!isNavigating || nextInstructionIndex >= instructions.length) return;

    const currentInstruction = instructions[nextInstructionIndex];
    const distanceToNext = map.distance(userPos, currentInstruction.latLng);

    if (distanceToNext < 50) {
      speakInstruction(currentInstruction);
      nextInstructionIndex++;
      
      if (nextInstructionIndex < instructions.length) {
        const nextInstruction = instructions[nextInstructionIndex];
        const nextDistance = map.distance(userPos, nextInstruction.latLng);
        
        if (nextDistance < 150) {
          speak(`After that, ${nextInstruction.text}`);
        }
      }
    } else if (nextInstructionIndex === instructions.length - 1 && distanceToNext < 20) {
      speak("You have arrived at your destination");
      isNavigating = false;
    }
  }

  function speakInstruction(instruction) {
    let text = instruction.text;
    
    text = text.replace(/Continue/g, "Continue for");
    text = text.replace(/Destination/g, "You have reached your destination");
    text = text.replace(/left/g, "Turn left");
    text = text.replace(/right/g, "Turn right");
    text = text.replace(/sharp left/g, "Take a sharp left");
    text = text.replace(/sharp right/g, "Take a sharp right");
    text = text.replace(/slight left/g, "Bear left");
    text = text.replace(/slight right/g, "Bear right");
    
    if (instruction.distance > 0) {
      const distance = instruction.distance < 1000 ? 
        `${Math.round(instruction.distance)} meters` : 
        `${(instruction.distance / 1000).toFixed(1)} kilometers`;
      text = `In ${distance}, ${text}`;
    }
    
    speak(text);
    lastSpokenInstruction = text;
  }

  function repeatInstruction() {
    if (lastSpokenInstruction) {
      speak(lastSpokenInstruction);
    } else {
      speak("No instructions available");
    }
  }

  function handleLocationError(error) {
    let errorMsg = "Error getting your location: ";
    switch(error.code) {
      case error.PERMISSION_DENIED:
        errorMsg += "Location permission denied. Please enable it in your browser settings.";
        break;
      case error.POSITION_UNAVAILABLE:
        errorMsg += "Location information unavailable.";
        break;
      case error.TIMEOUT:
        errorMsg += "Location request timed out. Please try again.";
        break;
      case error.UNKNOWN_ERROR:
        errorMsg += "An unknown error occurred.";
        break;
    }
    console.error(errorMsg);
    
    userPos = [5.7328, 0.0447];
    if (userMarker) {
      userMarker.setLatLng(userPos);
    } else {
      const customIcon = L.icon({
        iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        className: 'blinking'
      });
      userMarker = L.marker(userPos, { icon: customIcon }).addTo(map);
    }
    map.setView(userPos, 15);
  }

  function recenterMap() {
    if (userPos.length) {
      map.setView(userPos, 15);
    }
  }

  function doSearch() {
    const q = document.getElementById('searchInput').value;
    if (!q || !userPos.length) {
      speak("Please enter a search term and ensure location services are enabled.");
      return;
    }
    
    // First try to find matching house in estate
    const houseMatch = houseData.find(house => 
      house.properties.HOUSE_NUMB && 
      house.properties.HOUSE_NUMB.toUpperCase() === q.toUpperCase()
    );
    
    if (houseMatch) {
      selectHouse(houseMatch);
      return;
    }
    
    // If not a house number, search external locations
    fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q + ' Ghana')}`)
      .then(res => res.json())
      .then(data => {
        if (!data.length) {
          speak("Location not found. Please try another search term.");
          return alert('Location not found');
        }
        const dest = [parseFloat(data[0].lat), parseFloat(data[0].lon)];
        
        if (isInEstate(dest[0], dest[1])) {
          // If destination is in estate but not a house number, use road snapping
          const waypoints = getRoadWaypoints(userPos, dest);
          routingControl.setWaypoints(waypoints);
          map.setView(dest, 15);
          speak(`Routing to ${q} via estate roads`);
        } else {
          // External location - route directly
          routingControl.setWaypoints([
            L.latLng(userPos[0], userPos[1]), 
            L.latLng(dest[0], dest[1])
          ]);
          map.setView(dest, 15);
          speak(`Routing to ${q}`);
        }
      })
      .catch(err => {
        console.error('Search error:', err);
        speak("Error searching for location. Please try again.");
        alert('Error searching for location');
      });
  }

  function selectHouse(house) {
    if (highlightedHouse) {
      map.removeLayer(highlightedHouse);
    }
    
    const houseCoords = house.geometry.coordinates;
    const houseLatLng = [houseCoords[1], houseCoords[0]];

    map.flyTo(houseLatLng, 18);

    const houseIcon = L.icon({
      iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
      shadowSize: [41, 41]
    });
    
    // Create popup content with image if available
    let popupContent = `<b>House:</b> ${house.properties.HOUSE_NUMB}`;
    if (house.properties.Image_URL) {
      popupContent += `<br><img src="${house.properties.Image_URL}" style="max-width:250px; max-height:250px; margin-top:10px;">`;
    }
    
    highlightedHouse = L.marker(houseLatLng, { icon: houseIcon })
      .addTo(map)
      .bindPopup(popupContent)
      .openPopup();

    if (userPos.length) {
      if (routingControl) {
        map.removeControl(routingControl);
      }

      // Route directly to the building point
      routingControl = L.Routing.control({
        waypoints: [
          L.latLng(userPos[0], userPos[1]),
          L.latLng(houseLatLng[0], houseLatLng[1])
        ],
        routeWhileDragging: false,
        showAlternatives: false,
        addWaypoints: false,
        draggableWaypoints: false,
        fitSelectedRoutes: true,
        lineOptions: {
          styles: [
            { className: 'route-line', weight: 5, opacity: 0.8 },
            { className: 'route-line-upcoming', weight: 4, opacity: 0.5 }
          ]
        },
        createMarker: function() { return null; }
      }).addTo(map);
      
      speak(`Routing to house ${house.properties.HOUSE_NUMB}`);
    } else {
      speak("Please enable location services to get directions.");
      alert("Please enable location services to get directions.");
    }
  }

  window.addEventListener('beforeunload', () => {
    if (watchId) {
      navigator.geolocation.clearWatch(watchId);
    }
    window.speechSynthesis.cancel();
  });
</script>
</body>
</html>